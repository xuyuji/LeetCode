# 最长回文子串

给定两个大小为 m 和 n 的有序数组 **nums1 **和 **nums2 **。

请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。

**示例 1:**

```
nums1 = [1, 3]
nums2 = [2]

中位数是 2.0

```

**示例 2:**

```
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba"也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
```


# 解题思路

* Solution1为暴力破解法，遍历所有字符串，判断字符串是否是回文数。

  碰到长一点的字符串效率堪忧，无法通过耗时测试。

* Solution2为中心扩散法，耗时达标。

  参考知乎回答实现：https://www.zhihu.com/question/40965749/answer/152396279

* Solution3为中心扩散法优化，将偶数回文数转化为奇数回文数处理模式，效率有细微提高。

  参考leetcode-cn该题高效率答案。

* Solution4为中心扩散法进一步优化，用char数组替换substring方法，效率大幅提高。

  参考leetcode-cn该题高效率答案。

* 假定遍历的当前中心点距离最近的边长度为x，那么可以找到的最长回文数最多是x，若是已经找到超过x的回文数，那么这次扩散搜索就没有必要了。

  可以从中心点开始搜索，慢慢向两侧扩散，如果找到足够长的回文数后，边缘部分的搜索可以省略，效率进一步提高。

* 在知乎回答中看到有人提过弄一个反向数组辅助查找，可以尝试下。

* Manacher算法

* 动态规划

